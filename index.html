<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WhiskUnlimited - AI Image Generator</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/logo.png">
  <link rel="apple-touch-icon" href="/logo.png">
  <script src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.2/dist/browser-image-compression.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      min-height: 100vh;
      color: #fff;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    
    header {
      text-align: center;
      padding: 30px 0;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      margin-bottom: 30px;
    }
    
    h1 {
      font-size: 2.5rem;
      background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 10px;
    }
    
    .subtitle {
      color: #a0a0a0;
      font-size: 1rem;
    }
    
    .section {
      background: rgba(22, 33, 62, 0.8);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 24px;
      border: 2px solid transparent;
      background-image: linear-gradient(rgba(22, 33, 62, 0.9), rgba(22, 33, 62, 0.9)), 
                        linear-gradient(135deg, #667eea, #764ba2, #48dbfb);
      background-origin: border-box;
      background-clip: padding-box, border-box;
    }
    
    .section-title {
      font-size: 1.2rem;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .section-title span {
      background: linear-gradient(90deg, #667eea, #764ba2);
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 0.8rem;
    }
    
    .token-section {
      display: flex;
      gap: 12px;
      align-items: flex-start;
      flex-wrap: wrap;
    }
    
    .token-input {
      flex: 1;
      min-width: 300px;
      padding: 14px 18px;
      border-radius: 10px;
      border: 2px solid rgba(255,255,255,0.2);
      background: rgba(0,0,0,0.3);
      color: #fff;
      font-size: 14px;
      transition: border-color 0.3s;
    }
    
    .token-input:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .token-input::placeholder {
      color: #666;
    }
    
    .btn {
      padding: 14px 24px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      transition: all 0.3s;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    
    .btn-primary {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
    }
    
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(102,126,234,0.4);
    }
    
    .btn-danger {
      background: rgba(255,107,107,0.2);
      color: #ff6b6b;
      border: 1px solid rgba(255,107,107,0.3);
    }
    
    .btn-danger:hover {
      background: rgba(255,107,107,0.3);
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .reference-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
    }
    
    .upload-box {
      background: rgba(0,0,0,0.2);
      border: 2px dashed rgba(255,255,255,0.2);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      min-height: 180px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    .upload-box:hover {
      border-color: #667eea;
      background: rgba(102,126,234,0.1);
    }
    
    .upload-box.has-image {
      border-style: solid;
      border-color: #48dbfb;
    }
    
    .upload-box img {
      max-width: 100%;
      max-height: 120px;
      border-radius: 8px;
      margin-bottom: 10px;
    }
    
    .upload-icon {
      font-size: 2.5rem;
      margin-bottom: 10px;
      opacity: 0.7;
    }
    
    .upload-label {
      font-weight: 600;
      margin-bottom: 5px;
    }
    
    .upload-hint {
      font-size: 0.8rem;
      color: #888;
    }
    
    .caption-text {
      font-size: 0.75rem;
      color: #48dbfb;
      margin-top: 8px;
      max-height: 40px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .prompt-textarea {
      width: 100%;
      min-height: 120px;
      padding: 16px;
      border-radius: 10px;
      border: 2px solid rgba(255,255,255,0.2);
      background: rgba(0,0,0,0.3);
      color: #fff;
      font-size: 14px;
      resize: vertical;
      font-family: inherit;
    }
    
    .prompt-textarea:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .prompt-textarea::placeholder {
      color: #666;
    }
    
    .options-row {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      margin-top: 16px;
    }
    
    .option-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    
    .option-label {
      font-size: 0.85rem;
      color: #aaa;
    }
    
    .option-select {
      padding: 10px 16px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(0,0,0,0.3);
      color: #fff;
      font-size: 14px;
      cursor: pointer;
    }
    
    .option-select:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .generate-section {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 16px;
    }
    
    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      color: #aaa;
    }
    
    .checkbox-label input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: #667eea;
    }
    
    .status-bar {
      background: rgba(0,0,0,0.3);
      padding: 12px 20px;
      border-radius: 10px;
      margin-top: 16px;
      display: none;
    }
    
    .status-bar.visible {
      display: block;
    }
    
    .status-text {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .spinner {
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255,255,255,0.2);
      border-top-color: #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .results-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    
    .result-card {
      background: rgba(0,0,0,0.2);
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .result-image {
      width: 100%;
      aspect-ratio: 1;
      object-fit: cover;
    }
    
    .result-info {
      padding: 12px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      max-height: 150px;
      overflow-y: auto;
    }
    
    .result-prompt {
      font-size: 0.85rem;
      color: #fff;
      margin-bottom: 4px;
      line-height: 1.4;
    }
    
    .result-prompt-label {
      color: #feca57;
      font-weight: 600;
      font-size: 0.75rem;
      margin-bottom: 4px;
    }
    
    .result-caption {
      font-size: 0.8rem;
      color: #a0a0a0;
      font-style: italic;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255,255,255,0.05);
    }
    
    .result-caption-label {
      color: #48dbfb;
      font-weight: 600;
      font-size: 0.75rem;
      margin-bottom: 4px;
      font-style: normal;
    }
    
    .result-actions {
      padding: 10px;
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    
    /* Generation Timer */
    .generation-timer {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: linear-gradient(135deg, rgba(72, 219, 251, 0.2), rgba(102, 126, 234, 0.2));
      border: 1px solid rgba(72, 219, 251, 0.4);
      border-radius: 20px;
      padding: 6px 14px;
      font-family: 'Courier New', monospace;
      font-size: 1rem;
      font-weight: 600;
    }
    
    .generation-timer.running {
      animation: timerPulse 1s infinite;
      border-color: #48dbfb;
    }
    
    .generation-timer.completed {
      background: linear-gradient(135deg, rgba(0, 184, 148, 0.2), rgba(0, 184, 148, 0.3));
      border-color: #00b894;
    }
    
    @keyframes timerPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    .timer-icon {
      font-size: 1.1rem;
    }
    
    #timerDisplay {
      color: #48dbfb;
      min-width: 45px;
    }
    
    .generation-timer.completed #timerDisplay {
      color: #00b894;
    }
    
    .result-actions .btn {
      flex: 1;
      min-width: 60px;
      padding: 8px 6px;
      font-size: 0.75rem;
    }
    
    .btn-icon {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      color: #fff;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .btn-icon:hover {
      background: rgba(255,255,255,0.2);
    }
    
    .btn-success {
      background: linear-gradient(135deg, #00b894, #00a388);
    }
    
    .btn-success:hover {
      background: linear-gradient(135deg, #00a388, #009177);
    }
    
    .btn-purple {
      background: linear-gradient(135deg, #a855f7, #9333ea);
    }
    
    .btn-purple:hover {
      background: linear-gradient(135deg, #9333ea, #7e22ce);
    }
    
    .btn-info {
      background: linear-gradient(135deg, #17a2b8, #138496);
    }
    
    .btn-info:hover {
      background: linear-gradient(135deg, #138496, #117a8b);
    }
    
    .btn-secondary {
      background: linear-gradient(135deg, #6c757d, #5a6268);
    }
    
    .btn-secondary:hover {
      background: linear-gradient(135deg, #5a6268, #4e555b);
    }
    
    .pagination-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin-top: 20px;
      flex-wrap: wrap;
    }
    
    .page-numbers {
      display: flex;
      gap: 5px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .page-btn {
      min-width: 40px;
      height: 40px;
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.1);
      color: #fff;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s;
    }
    
    .page-btn:hover {
      background: rgba(102, 126, 234, 0.5);
    }
    
    .page-btn.active {
      background: linear-gradient(135deg, #667eea, #764ba2);
      border-color: #667eea;
    }
    
    .pagination-btn {
      padding: 10px 16px;
    }
    
    .header-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .error-message {
      background: rgba(255,107,107,0.1);
      border: 1px solid rgba(255,107,107,0.3);
      color: #ff6b6b;
      padding: 16px;
      border-radius: 10px;
      margin-top: 16px;
      display: none;
    }
    
    .error-message.visible {
      display: block;
    }
    
    .token-help {
      margin-top: 12px;
      padding: 16px;
      background: rgba(254,202,87,0.1);
      border: 1px solid rgba(254,202,87,0.3);
      border-radius: 10px;
      font-size: 0.9rem;
    }
    
    .token-help h4 {
      color: #feca57;
      margin-bottom: 8px;
    }
    
    .token-help ol {
      margin-left: 20px;
      color: #ccc;
      line-height: 1.8;
    }
    
    .token-help code {
      background: rgba(0,0,0,0.3);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: monospace;
    }
    
    .hidden-input {
      display: none;
    }
    
    .token-status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.85rem;
      padding: 8px 12px;
      border-radius: 8px;
    }
    
    .token-status.valid {
      background: rgba(72,219,251,0.1);
      color: #48dbfb;
    }
    
    .token-status.invalid {
      background: rgba(255,107,107,0.1);
      color: #ff6b6b;
    }
    
    .clear-ref {
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(255,107,107,0.8);
      border: none;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      color: white;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .upload-box {
      position: relative;
    }
    
    .blink-warning {
      background: rgba(255, 50, 50, 0.15);
      border: 2px solid #ff3232;
      border-radius: 10px;
      padding: 12px 20px;
      margin-bottom: 20px;
      text-align: center;
      font-weight: 600;
      font-size: 0.95rem;
      color: #ff4444;
      animation: blink-red 1s ease-in-out infinite;
    }
    
    @keyframes blink-red {
      0%, 100% {
        opacity: 1;
        color: #ff4444;
        border-color: #ff3232;
        background: rgba(255, 50, 50, 0.15);
      }
      50% {
        opacity: 0.7;
        color: #ff6666;
        border-color: #ff5555;
        background: rgba(255, 50, 50, 0.25);
      }
    }
    
    /* Top Bar - Logo + Stats in same row inside container */
    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      flex-wrap: wrap;
      gap: 10px;
    }
    
    /* Top Left Logo */
    .top-logo {
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(22, 33, 62, 0.9);
      padding: 8px 15px;
      border-radius: 12px;
      border: 1px solid rgba(102,126,234,0.3);
    }
    
    .logo-tagline {
      font-size: 0.9rem;
      font-weight: 700;
      color: #48dbfb;
    }
    
    /* Top Right Stats */
    .top-stats {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    /* Promo Buttons */
    .promo-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 8px 14px;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.3s ease;
      border: 1px solid transparent;
    }
    
    .promo-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(0,0,0,0.3);
    }
    
    .veo-btn {
      background: linear-gradient(135deg, #ff6b6b, #ee5a24);
      border-color: rgba(255,107,107,0.5);
    }
    
    .veo-btn:hover {
      background: linear-gradient(135deg, #ff5252, #d63031);
    }
    
    .tts-btn {
      background: linear-gradient(135deg, #00b894, #00cec9);
      border-color: rgba(0,184,148,0.5);
    }
    
    .tts-btn:hover {
      background: linear-gradient(135deg, #00a383, #00b5b8);
    }
    
    .promo-icon {
      font-size: 1rem;
      margin-bottom: 2px;
    }
    
    .promo-text {
      font-size: 0.7rem;
      font-weight: 700;
      color: #fff;
      white-space: nowrap;
    }
    
    .promo-link {
      font-size: 0.55rem;
      color: rgba(255,255,255,0.8);
      margin-top: 1px;
    }
    
    .mini-stat {
      background: rgba(22, 33, 62, 0.95);
      border: 1px solid rgba(102,126,234,0.3);
      border-radius: 8px;
      padding: 6px 12px;
      text-align: center;
      backdrop-filter: blur(10px);
    }
    
    .mini-stat-num {
      display: block;
      font-size: 1rem;
      font-weight: 700;
      background: linear-gradient(90deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .mini-stat-label {
      font-size: 0.65rem;
      color: #888;
      text-transform: uppercase;
    }
    
    .bonus-badge {
      position: absolute;
      top: -5px;
      right: -5px;
      background: linear-gradient(135deg, #00b894, #00cec9);
      color: #fff;
      font-size: 0.6rem;
      font-weight: 700;
      padding: 2px 5px;
      border-radius: 8px;
      animation: bonusPulse 2s infinite;
    }
    
    @keyframes bonusPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    
    .mini-stat {
      position: relative;
    }
    
    .share-btn {
      background: linear-gradient(135deg, #667eea, #764ba2);
      border: none;
      border-radius: 8px;
      padding: 6px 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 5px;
      transition: all 0.3s;
      color: #fff;
      font-size: 0.75rem;
      font-weight: 600;
    }
    
    .share-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 15px rgba(102,126,234,0.4);
    }
    
    .share-btn:active {
      transform: scale(0.95);
    }
    
    .share-text {
      white-space: nowrap;
    }
    
    /* Legacy Stats Counter Styles (unused) */
    .stats-bar {
      display: none;
    }
    
    .stat-box {
      background: linear-gradient(135deg, rgba(102,126,234,0.2), rgba(118,75,162,0.2));
      border: 1px solid rgba(102,126,234,0.4);
      border-radius: 12px;
      padding: 12px 24px;
      text-align: center;
      min-width: 150px;
      backdrop-filter: blur(10px);
    }
    
    .stat-number {
      font-size: 1.8rem;
      font-weight: 700;
      background: linear-gradient(90deg, #48dbfb, #ff6b6b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      line-height: 1.2;
    }
    
    .stat-label {
      font-size: 0.75rem;
      color: #a0a0a0;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-top: 4px;
    }
    
    @keyframes countUp {
      from { opacity: 0.5; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }
    
    .stat-number.updating {
      animation: countUp 0.3s ease-out;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Top Bar - Logo Left, Stats Right -->
    <div class="top-bar">
      <div class="top-logo">
        <img src="/logo.png" alt="Logo" style="width: 45px; height: 45px; border-radius: 10px;">
        <span class="logo-tagline">Create AI Magic</span>
      </div>
      
      <div class="top-stats">
        <a href="https://veounlimited.com/" target="_blank" class="promo-btn veo-btn">
          <span class="promo-icon">üé¨</span>
          <span class="promo-text">Veo 3.1 Unlimited</span>
          <span class="promo-link">veounlimited.com</span>
        </a>
        <a href="https://audiogen.pro" target="_blank" class="promo-btn tts-btn">
          <span class="promo-icon">üîä</span>
          <span class="promo-text">Text to Speech</span>
          <span class="promo-link">audiogen.pro</span>
        </a>
        <div class="mini-stat">
          <span class="mini-stat-num" id="visitorCount">0</span>
          <span class="mini-stat-label">Total Visitors</span>
        </div>
        <div class="mini-stat">
          <span class="mini-stat-num" id="generationCount">0</span>
          <span class="mini-stat-label">Total Generated</span>
        </div>
        <div class="mini-stat" style="border-color: rgba(0, 184, 148, 0.4);">
          <span class="mini-stat-num" id="remainingLimit" style="color: #00b894;">1000</span>
          <span class="mini-stat-label">Daily Limit</span>
          <span class="bonus-badge" id="bonusBadge" style="display: none;">+0</span>
        </div>
        <div class="share-btn" id="shareBtn" onclick="copyReferralLink()" title="Share to get +200 limit per visitor">
          <span>üì§</span>
          <span class="share-text">Share +200</span>
        </div>
      </div>
    </div>
    
    <div class="blink-warning">
      ‚ö†Ô∏è WARNING: Do not refresh the page or your generated images will be lost! Download them first, then refresh.
    </div>

    <div class="section">
      <div class="section-title">
        <span>Step 1</span>
        Generation Mode
      </div>
      <div style="display: flex; gap: 12px; flex-wrap: wrap;">
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 12px 20px; border-radius: 10px; border: 2px solid #667eea; background: rgba(102,126,234,0.1); transition: all 0.3s;" id="modeTokenLabel">
          <input type="radio" name="authMode" value="token" checked onchange="switchAuthMode('token')" style="accent-color: #667eea;">
          <span style="font-weight: 600;">Text To Image</span>
          <span style="font-size: 0.8rem; color: #48dbfb;">(Prompt Only)</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 12px 20px; border-radius: 10px; border: 2px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.2); transition: all 0.3s;" id="modeCookieLabel">
          <input type="radio" name="authMode" value="cookie" onchange="switchAuthMode('cookie')" style="accent-color: #667eea;">
          <span style="font-weight: 600;">Reference Images</span>
          <span style="font-size: 0.8rem; color: #feca57;">(Subject/Scene/Style)</span>
        </label>
      </div>
    </div>
    
    <div class="section" id="referenceSection" style="display: none;">
      <div class="section-title">
        <span>Step 2</span>
        Reference Images (Optional)
      </div>
      <div class="reference-grid">
        <div class="upload-box" id="subjectBox" onclick="document.getElementById('subjectInput').click()">
          <input type="file" id="subjectInput" class="hidden-input" accept="image/*" onchange="handleUpload('subject', this)">
          <div class="upload-icon">üë§</div>
          <div class="upload-label">Subject</div>
          <div class="upload-hint">Character or main object</div>
          <div id="subjectCaption" style="font-size: 0.7rem; color: #48dbfb; margin-top: 4px;"></div>
        </div>
        <div class="upload-box" id="sceneBox" onclick="document.getElementById('sceneInput').click()">
          <input type="file" id="sceneInput" class="hidden-input" accept="image/*" onchange="handleUpload('scene', this)">
          <div class="upload-icon">üèûÔ∏è</div>
          <div class="upload-label">Scene</div>
          <div class="upload-hint">Background or setting</div>
          <div id="sceneCaption" style="font-size: 0.7rem; color: #48dbfb; margin-top: 4px;"></div>
        </div>
        <div class="upload-box" id="styleBox" onclick="document.getElementById('styleInput').click()">
          <input type="file" id="styleInput" class="hidden-input" accept="image/*" onchange="handleUpload('style', this)">
          <div class="upload-icon">üé®</div>
          <div class="upload-label">Style</div>
          <div class="upload-hint">Art style reference</div>
          <div id="styleCaption" style="font-size: 0.7rem; color: #48dbfb; margin-top: 4px;"></div>
        </div>
      </div>
    </div>


    <div class="section">
      <div class="section-title">
        <span id="promptStep">Step 2</span>
        Prompt &amp; Settings
      </div>
      
      <div class="mode-toggle" style="display: flex; gap: 10px; margin-bottom: 16px;">
        <label class="mode-option" id="singleModeLabel" style="flex: 1; padding: 12px; border: 2px solid #667eea; border-radius: 10px; cursor: pointer; text-align: center; background: rgba(102,126,234,0.1);">
          <input type="radio" name="promptMode" value="single" checked onchange="switchPromptMode('single')" style="display: none;">
          <div style="font-weight: 600;">Single Prompt</div>
          <div style="font-size: 0.8rem; color: #a0a0a0;">1 prompt at a time</div>
        </label>
        <label class="mode-option" id="batchModeLabel" style="flex: 1; padding: 12px; border: 2px solid rgba(255,255,255,0.2); border-radius: 10px; cursor: pointer; text-align: center;">
          <input type="radio" name="promptMode" value="batch" onchange="switchPromptMode('batch')" style="display: none;">
          <div style="font-weight: 600;">Batch Mode</div>
        </label>
      </div>
      
      <div id="singlePromptSection">
        <textarea id="promptInput" class="prompt-textarea" placeholder="Enter your prompt here...

Examples:
- A majestic lion in a cyberpunk city
- Watercolor painting of a sunset over mountains
- Professional headshot in anime style"></textarea>
      </div>
      
      <div id="batchPromptSection" style="display: none;">
        <textarea id="batchPromptInput" class="prompt-textarea" style="height: 200px;" placeholder="Enter one prompt per line (max 100 prompts)

Example:
A cute cat playing with yarn
A dog running on the beach
A bird flying over mountains
Sunset over a calm lake
..."></textarea>
        <div style="margin-top: 8px; padding: 8px; background: rgba(102,126,234,0.1); border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
          <span id="promptCount" style="font-size: 0.85rem; color: #a0a0a0;">0 prompts detected</span>
          <span id="promptLimit" style="font-size: 0.8rem; color: #feca57;">Max: 100 prompts</span>
        </div>
      </div>
      
      <div class="options-row">
        <div class="option-group">
          <label class="option-label">Aspect Ratio</label>
          <select id="aspectRatio" class="option-select">
            <option value="IMAGE_ASPECT_RATIO_SQUARE">Square (1:1)</option>
            <option value="IMAGE_ASPECT_RATIO_LANDSCAPE" selected>Landscape (16:9)</option>
            <option value="IMAGE_ASPECT_RATIO_PORTRAIT">Portrait (9:16)</option>
          </select>
        </div>
        <div class="option-group">
          <label class="option-label">Image Count</label>
          <select id="imageCount" class="option-select">
            <option value="1">1 Image</option>
            <option value="2" selected>2 Images</option>
            <option value="3">3 Images</option>
            <option value="4">4 Images</option>
          </select>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="generate-section">
        <div style="display: flex; gap: 20px; flex-wrap: wrap;">
          <label class="checkbox-label">
            <input type="checkbox" id="autoDownload">
            Auto-download images
          </label>
        </div>
        <button class="btn btn-primary" id="generateBtn" onclick="generateImages()">
          Generate Images
        </button>
      </div>
      
      <div id="statusBar" class="status-bar">
        <div class="status-text">
          <div class="spinner"></div>
          <span id="statusText">Processing...</span>
        </div>
      </div>
      
      <div id="errorMessage" class="error-message"></div>
    </div>

    <div class="section" id="resultsSection" style="display: none;">
      <div class="section-title" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
        <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
          <span>Generated Images (History) - <span id="totalImagesCount">0</span> images</span>
          <div id="generationTimer" class="generation-timer" style="display: none;">
            <span class="timer-icon">‚è±Ô∏è</span>
            <span id="timerDisplay">00:00</span>
          </div>
        </div>
        <div class="header-actions">
          <button class="btn btn-success" onclick="copyAllPrompts()" style="padding: 8px 12px; font-size: 0.85rem;">Copy All</button>
          <button class="btn btn-info" onclick="copyAllCaptions()" style="padding: 8px 12px; font-size: 0.85rem;">Copy All Captions</button>
          <button class="btn btn-purple" onclick="downloadZip()" style="padding: 8px 12px; font-size: 0.85rem;">Download ZIP</button>
          <button class="btn btn-danger" onclick="clearHistory()" style="padding: 8px 12px; font-size: 0.85rem;">Clear All</button>
        </div>
      </div>
      <div id="resultsGrid" class="results-grid"></div>
      <div id="paginationControls" class="pagination-controls" style="display: none;">
        <button class="btn btn-secondary pagination-btn" id="prevPageBtn" onclick="changePage('prev')">Previous</button>
        <div id="pageNumbers" class="page-numbers"></div>
        <button class="btn btn-secondary pagination-btn" id="nextPageBtn" onclick="changePage('next')">Next</button>
        <button class="btn btn-secondary pagination-btn" id="lastPageBtn" onclick="changePage('last')">Last</button>
      </div>
    </div>
    
    <div class="section" id="failedPromptsSection" style="display: none;">
      <div class="section-title" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
        <span style="color: #ff6b6b;">Failed Prompts - <span id="failedCount">0</span></span>
        <div class="header-actions">
          <button class="btn btn-success" onclick="copyFailedPrompts()" style="padding: 8px 12px; font-size: 0.85rem;">Copy All Failed</button>
          <button class="btn btn-primary" onclick="retryFailedPrompts()" style="padding: 8px 12px; font-size: 0.85rem;">Retry All</button>
          <button class="btn btn-danger" onclick="clearFailedPrompts()" style="padding: 8px 12px; font-size: 0.85rem;">Clear</button>
        </div>
      </div>
      <textarea id="failedPromptsList" readonly style="width: 100%; height: 150px; background: rgba(255,107,107,0.1); border: 1px solid rgba(255,107,107,0.3); border-radius: 8px; padding: 12px; color: #ff6b6b; font-family: monospace; font-size: 0.9rem; resize: vertical;"></textarea>
    </div>
  </div>

  <script>
    const state = {
      authMode: 'token',
      workflowId: generateUUID(),
      sessionId: ';' + Date.now(),
      references: {
        subject: null,
        scene: null,
        style: null
      }
    };
    
    // Store image history for ZIP download and copy all
    const imageHistory = [];
    
    // Store failed prompts
    const failedPrompts = [];
    
    // Pagination settings
    const IMAGES_PER_PAGE = 50;
    let currentPage = 1;

    function generateUUID() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    }

    function switchAuthMode(mode) {
      state.authMode = mode;
      document.getElementById('referenceSection').style.display = mode === 'cookie' ? 'block' : 'none';
      document.getElementById('promptStep').textContent = mode === 'cookie' ? 'Step 3' : 'Step 2';
      
      document.getElementById('modeTokenLabel').style.borderColor = mode === 'token' ? '#667eea' : 'rgba(255,255,255,0.2)';
      document.getElementById('modeTokenLabel').style.background = mode === 'token' ? 'rgba(102,126,234,0.1)' : 'rgba(0,0,0,0.2)';
      document.getElementById('modeCookieLabel').style.borderColor = mode === 'cookie' ? '#667eea' : 'rgba(255,255,255,0.2)';
      document.getElementById('modeCookieLabel').style.background = mode === 'cookie' ? 'rgba(102,126,234,0.1)' : 'rgba(0,0,0,0.2)';
    }
    
    // Prompt mode state
    let promptMode = 'single';
    let batchRunning = false;
    let batchCancelled = false;
    
    // Generation Timer
    let timerInterval = null;
    let timerStartTime = null;
    
    function startGenerationTimer() {
      timerStartTime = Date.now();
      const timerEl = document.getElementById('generationTimer');
      const displayEl = document.getElementById('timerDisplay');
      
      timerEl.style.display = 'inline-flex';
      timerEl.classList.add('running');
      timerEl.classList.remove('completed');
      displayEl.textContent = '00:00';
      
      // Make sure results section is visible
      document.getElementById('resultsSection').style.display = 'block';
      
      timerInterval = setInterval(() => {
        const elapsed = Date.now() - timerStartTime;
        const minutes = Math.floor(elapsed / 60000);
        const seconds = Math.floor((elapsed % 60000) / 1000);
        displayEl.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }, 100);
    }
    
    function stopGenerationTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      
      const timerEl = document.getElementById('generationTimer');
      timerEl.classList.remove('running');
      timerEl.classList.add('completed');
      
      // Final time update
      if (timerStartTime) {
        const elapsed = Date.now() - timerStartTime;
        const minutes = Math.floor(elapsed / 60000);
        const seconds = Math.floor((elapsed % 60000) / 1000);
        document.getElementById('timerDisplay').textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
    }
    
    function switchPromptMode(mode) {
      promptMode = mode;
      document.getElementById('singlePromptSection').style.display = mode === 'single' ? 'block' : 'none';
      document.getElementById('batchPromptSection').style.display = mode === 'batch' ? 'block' : 'none';
      
      document.getElementById('singleModeLabel').style.borderColor = mode === 'single' ? '#667eea' : 'rgba(255,255,255,0.2)';
      document.getElementById('singleModeLabel').style.background = mode === 'single' ? 'rgba(102,126,234,0.1)' : 'transparent';
      document.getElementById('batchModeLabel').style.borderColor = mode === 'batch' ? '#667eea' : 'rgba(255,255,255,0.2)';
      document.getElementById('batchModeLabel').style.background = mode === 'batch' ? 'rgba(102,126,234,0.1)' : 'transparent';
      
      // Update button text
      document.getElementById('generateBtn').textContent = mode === 'batch' ? 'Start Batch Generation' : 'Generate Images';
    }
    
    const MAX_BATCH_PROMPTS = 200;
    
    // ============================================
    // REAL-TIME STATS TRACKING
    // ============================================
    
    // Format number with commas
    function formatNumber(num) {
      return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    }
    
    // Update stat display with animation
    function updateStatDisplay(elementId, value) {
      const el = document.getElementById(elementId);
      if (el) {
        el.classList.add('updating');
        el.textContent = formatNumber(value);
        setTimeout(() => el.classList.remove('updating'), 300);
      }
    }
    
    // Fetch and display stats
    async function fetchStats() {
      try {
        const response = await fetch('/api/stats');
        const stats = await response.json();
        updateStatDisplay('visitorCount', stats.total_visitors || 0);
        updateStatDisplay('generationCount', stats.total_generations || 0);
        
        // Fetch IP limit and referral info
        const limitResponse = await fetch('/api/ip-limit');
        const limitData = await limitResponse.json();
        updateRemainingLimit(limitData.remaining, limitData.bonus || 0);
        
        // Store referral code for sharing
        if (limitData.referralCode) {
          userReferralCode = limitData.referralCode;
        }
      } catch (e) {
        console.error('Stats fetch error:', e);
      }
    }
    
    // Referral system variables
    let userReferralCode = '';
    
    function updateRemainingLimit(remaining, bonus = 0) {
      const el = document.getElementById('remainingLimit');
      const bonusBadge = document.getElementById('bonusBadge');
      
      if (el) {
        el.textContent = remaining.toLocaleString();
        // Change color based on remaining
        if (remaining <= 100) {
          el.style.color = '#ff6b6b'; // Red when low
        } else if (remaining <= 500) {
          el.style.color = '#feca57'; // Yellow when medium
        } else {
          el.style.color = '#00b894'; // Green when high
        }
      }
      
      // Show bonus badge if user has earned bonus
      if (bonusBadge && bonus > 0) {
        bonusBadge.textContent = '+' + bonus;
        bonusBadge.style.display = 'block';
      }
    }
    
    // Copy referral link to clipboard
    async function copyReferralLink() {
      if (!userReferralCode) {
        try {
          const resp = await fetch('/api/referral/code');
          const data = await resp.json();
          userReferralCode = data.code;
        } catch (e) {
          alert('Error getting referral code!');
          return;
        }
      }
      
      const referralUrl = window.location.origin + '?ref=' + userReferralCode;
      
      try {
        await navigator.clipboard.writeText(referralUrl);
        
        // Show success feedback
        const btn = document.getElementById('shareBtn');
        const originalHTML = btn.innerHTML;
        btn.innerHTML = '<span>‚úÖ</span><span class="share-text">Copied!</span>';
        btn.style.background = 'linear-gradient(135deg, #00b894, #00cec9)';
        
        setTimeout(() => {
          btn.innerHTML = originalHTML;
          btn.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
        }, 2000);
        
      } catch (e) {
        // Fallback for older browsers
        const textarea = document.createElement('textarea');
        textarea.value = referralUrl;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        alert('Link copied: ' + referralUrl);
      }
    }
    
    // Process referral on page load
    async function processReferral() {
      const urlParams = new URLSearchParams(window.location.search);
      const refCode = urlParams.get('ref');
      
      if (refCode) {
        try {
          const resp = await fetch('/api/referral/visit', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ code: refCode })
          });
          const result = await resp.json();
          
          if (result.success) {
            console.log('Referral processed! Referrer got +200 bonus');
          }
          
          // Clean URL (remove ref param)
          const newUrl = window.location.origin + window.location.pathname;
          window.history.replaceState({}, document.title, newUrl);
          
        } catch (e) {
          console.error('Referral processing error:', e);
        }
      }
    }
    
    // Track visitor (once per session)
    async function trackVisitor() {
      if (sessionStorage.getItem('visitor_tracked')) return;
      try {
        await fetch('/api/stats/visitor', { method: 'POST' });
        sessionStorage.setItem('visitor_tracked', 'true');
        fetchStats(); // Refresh stats after tracking
      } catch (e) {
        console.error('Visitor tracking error:', e);
      }
    }
    
    // Track generation
    async function trackGeneration(count = 1) {
      try {
        await fetch('/api/stats/generation', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ count })
        });
        fetchStats(); // Refresh stats after generation
      } catch (e) {
        console.error('Generation tracking error:', e);
      }
    }
    
    // Initialize stats on page load
    document.addEventListener('DOMContentLoaded', () => {
      processReferral(); // Process referral code if present
      fetchStats();
      trackVisitor();
      // Auto-refresh stats every 30 seconds
      setInterval(fetchStats, 30000);
    });
    
    function updatePromptCount() {
      const text = document.getElementById('batchPromptInput').value;
      const prompts = text.split('\n').filter(line => line.trim() !== '');
      const count = prompts.length;
      const countEl = document.getElementById('promptCount');
      const limitEl = document.getElementById('promptLimit');
      
      if (count > MAX_BATCH_PROMPTS) {
        countEl.textContent = `${count} prompts (${count - MAX_BATCH_PROMPTS} over limit!)`;
        countEl.style.color = '#ff6b6b';
        limitEl.style.color = '#ff6b6b';
      } else if (count > 80) {
        countEl.textContent = `${count} prompts detected`;
        countEl.style.color = '#feca57';
        limitEl.style.color = '#feca57';
      } else {
        countEl.textContent = `${count} prompts detected`;
        countEl.style.color = '#48dbfb';
        limitEl.style.color = '#feca57';
      }
    }
    
    // Add event listener for batch prompt input
    document.addEventListener('DOMContentLoaded', function() {
      const batchInput = document.getElementById('batchPromptInput');
      if (batchInput) {
        batchInput.addEventListener('input', updatePromptCount);
      }
    });


    async function compressImage(file) {
      const options = {
        maxSizeMB: 1,
        maxWidthOrHeight: 1024,
        useWebWorker: true
      };
      try {
        return await imageCompression(file, options);
      } catch (e) {
        console.error('Compression failed:', e);
        return file;
      }
    }

    async function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          const base64 = reader.result.split(',')[1];
          resolve(base64);
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }
    
    // Fetch caption for generated image using pool credentials
    async function fetchCaptionForImage(imageBase64) {
      try {
        const response = await fetch('/api/caption-pool', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            imageData: imageBase64,
            workflowId: state.workflowId,
            sessionId: state.sessionId
          })
        });
        
        const result = await response.json();
        return result.caption || '';
      } catch (error) {
        console.error('Caption fetch error:', error);
        return '';
      }
    }

    function clearReference(type, event) {
      event.stopPropagation();
      state.references[type] = null;
      const box = document.getElementById(type + 'Box');
      const icons = { subject: 'üë§', scene: 'üèûÔ∏è', style: 'üé®' };
      const hints = { subject: 'Character or main object', scene: 'Background or setting', style: 'Art style reference' };
      box.innerHTML = `
        <input type="file" id="${type}Input" class="hidden-input" accept="image/*" onchange="handleUpload('${type}', this)">
        <div class="upload-icon">${icons[type]}</div>
        <div class="upload-label">${type.charAt(0).toUpperCase() + type.slice(1)}</div>
        <div class="upload-hint">${hints[type]}</div>
      `;
      box.classList.remove('has-image');
    }

    async function handleUpload(type, input) {
      if (!input.files[0]) return;
      
      const file = input.files[0];
      const box = document.getElementById(type + 'Box');
      
      box.innerHTML = '<div class="spinner"></div><div style="margin-top: 10px;">Processing...</div>';
      
      try {
        const compressed = await compressImage(file);
        const base64 = await fileToBase64(compressed);
        
        const previewUrl = URL.createObjectURL(compressed);
        
        state.references[type] = {
          base64: base64,
          caption: null,
          mediaGenerationId: null
        };
        
        box.innerHTML = `
          <button class="clear-ref" onclick="clearReference('${type}', event)">√ó</button>
          <img src="${previewUrl}" alt="${type}">
          <div class="upload-label">${type.charAt(0).toUpperCase() + type.slice(1)}</div>
          <div class="caption-text" id="${type}Caption">Ready for generation</div>
        `;
        box.classList.add('has-image');
        
      } catch (error) {
        console.error('Upload error:', error);
        const icons = { subject: 'üë§', scene: 'üèûÔ∏è', style: 'üé®' };
        box.innerHTML = `
          <div class="upload-icon">${icons[type]}</div>
          <div class="upload-label">${type.charAt(0).toUpperCase() + type.slice(1)}</div>
          <div class="upload-hint" style="color: #ff6b6b;">Upload failed. Try again.</div>
        `;
      }
    }

    function showStatus(text) {
      document.getElementById('statusBar').classList.add('visible');
      document.getElementById('statusText').textContent = text;
    }

    function hideStatus() {
      document.getElementById('statusBar').classList.remove('visible');
    }

    function showError(text) {
      const el = document.getElementById('errorMessage');
      el.textContent = text;
      el.classList.add('visible');
    }

    function hideError() {
      document.getElementById('errorMessage').classList.remove('visible');
    }

    function checkAuthError(data) {
      if (data.error) {
        const errorMsg = typeof data.error === 'string' ? data.error : (data.error.message || '');
        
        // Show generic error messages - hide technical details
        if (errorMsg.toLowerCase().includes('api error') || 
            errorMsg.toLowerCase().includes('try again')) {
          throw new Error('API error. Please try again.');
        }
        
        // Generic error for any other API issues
        throw new Error('Generation failed. Please try again.');
      }
      return data;
    }

    async function uploadReference(type, base64) {
      const categoryMap = {
        subject: 'MEDIA_CATEGORY_SUBJECT',
        scene: 'MEDIA_CATEGORY_SCENE',
        style: 'MEDIA_CATEGORY_STYLE'
      };
      
      const response = await fetch('/api/upload', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          usePool: true,
          imageData: 'data:image/jpeg;base64,' + base64,
          category: categoryMap[type],
          workflowId: state.workflowId,
          sessionId: state.sessionId
        })
      });
      
      const data = await response.json();
      return checkAuthError(data);
    }

    async function generateImages() {
      // Handle batch mode
      if (promptMode === 'batch') {
        return generateBatch();
      }
      
      const prompt = document.getElementById('promptInput').value.trim();
      if (!prompt) {
        showError('Please enter a prompt!');
        return;
      }
      
      hideError();
      const btn = document.getElementById('generateBtn');
      btn.disabled = true;
      
      // Start generation timer
      startGenerationTimer();
      
      try {
        const recipeMediaInputs = [];
        const aspectRatio = document.getElementById('aspectRatio').value;
        const imageCount = parseInt(document.getElementById('imageCount').value);
        
        const categoryMap = {
          subject: 'MEDIA_CATEGORY_SUBJECT',
          scene: 'MEDIA_CATEGORY_SCENE',
          style: 'MEDIA_CATEGORY_STYLE'
        };
        
        let finalPrompt = prompt;
        
        if (state.authMode === 'cookie') {
          // Get captions from reference images and combine them
          let subjectCaption = '';
          let sceneCaption = '';
          let styleCaption = '';
          
          for (const type of ['subject', 'scene', 'style']) {
            if (state.references[type] && state.references[type].base64) {
              showStatus(`Analyzing ${type} image...`);
              
              const uploadResult = await uploadReference(type, state.references[type].base64);
              console.log(`${type} upload result:`, uploadResult);
              
              if (uploadResult.caption) {
                // Extract first 200 chars of caption for each
                const shortCaption = uploadResult.caption.substring(0, 300);
                
                if (type === 'subject') {
                  subjectCaption = shortCaption;
                } else if (type === 'scene') {
                  sceneCaption = shortCaption;
                } else if (type === 'style') {
                  styleCaption = shortCaption;
                }
              }
            }
          }
          
          // Build combined prompt from captions
          if (subjectCaption || sceneCaption || styleCaption) {
            showStatus('Building combined prompt...');
            
            let combinedParts = [];
            if (subjectCaption) {
              combinedParts.push(`Subject: ${subjectCaption}`);
            }
            if (sceneCaption) {
              combinedParts.push(`Scene: ${sceneCaption}`);
            }
            if (styleCaption) {
              combinedParts.push(`Style: ${styleCaption}`);
            }
            
            // Combine with user prompt
            finalPrompt = `${prompt}. ${combinedParts.join('. ')}`;
            console.log('Combined prompt:', finalPrompt.substring(0, 200));
          }
        }
        
        showStatus('Generating images...');
        
        const allImages = [];
        
        // Get the prompt and captions before starting generation
        const usedPrompt = document.getElementById('promptInput').value.trim();
        const captions = [];
        if (state.references.subject?.caption) captions.push('Subject: ' + state.references.subject.caption);
        if (state.references.scene?.caption) captions.push('Scene: ' + state.references.scene.caption);
        if (state.references.style?.caption) captions.push('Style: ' + state.references.style.caption);
        const captionText = captions.join(' | ');
        
        // Generate images using API pool
        for (let i = 0; i < imageCount; i++) {
          showStatus(`Generating image ${i + 1} of ${imageCount}...`);
          
          const response = await fetch('/api/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              usePool: true,
              mode: state.authMode === 'cookie' ? 'reference' : 'text2img',
              prompt: state.authMode === 'cookie' ? finalPrompt : prompt,
              aspectRatio: aspectRatio,
              references: state.authMode === 'cookie' ? state.references : null,
              workflowId: state.workflowId,
              sessionId: state.sessionId,
              seed: Math.floor(Math.random() * 2147483647)
            })
          });
          
          const result = await response.json();
          console.log('Generate result:', result);
          
          // Update remaining limit from response
          if (result.ipLimit) {
            updateRemainingLimit(result.ipLimit.remaining);
          }
          
          if (result.error) {
            throw new Error(result.error);
          }
          
          // Show image immediately as it's generated
          // Caption is now included in the response from server (same credential used)
          if (result.imagePanels) {
            for (const panel of result.imagePanels) {
              if (panel.generatedImages) {
                for (const img of panel.generatedImages) {
                  if (img.encodedImage) {
                    allImages.push(img.encodedImage);
                    // Caption comes from server response (uses same credential's cookies)
                    const imageCaption = img.caption || captionText || '';
                    displayResults([img.encodedImage], usedPrompt, imageCaption);
                  }
                }
              }
            }
          }
          
          if (result.generatedImages) {
            console.log('Processing generatedImages, count:', result.generatedImages.length);
            for (const img of result.generatedImages) {
              console.log('Image has caption:', !!img.caption, 'Caption:', img.caption?.substring(0, 50));
              if (img.encodedImage) {
                allImages.push(img.encodedImage);
                // Caption comes from server response (uses same credential's cookies)
                const imageCaption = img.caption || captionText || '';
                console.log('Final imageCaption:', imageCaption?.substring(0, 50));
                displayResults([img.encodedImage], usedPrompt, imageCaption);
              }
            }
          }
        }
        
        hideStatus();
        stopGenerationTimer();
        showStatus(`Generated ${allImages.length} images!`);
        setTimeout(hideStatus, 2000);
        
        // Track generation stats
        if (allImages.length > 0) {
          trackGeneration(allImages.length);
        }
        
        if (document.getElementById('autoDownload').checked) {
          downloadAllImages(allImages);
        }
        
        // Re-enable button after success
        btn.disabled = false;
        
      } catch (error) {
        hideStatus();
        stopGenerationTimer();
        console.error('Generation error:', error);
        showError('API error. Please try again.');
        btn.disabled = false;
      }
    }
    
    // Batch generation with parallel threads
    async function generateBatch() {
      
      const batchText = document.getElementById('batchPromptInput').value;
      let prompts = batchText.split('\n').filter(line => line.trim() !== '').map(line => line.trim());
      
      if (prompts.length === 0) {
        showError('Please enter at least one prompt (one per line)!');
        return;
      }
      
      // Enforce 200 prompt limit
      if (prompts.length > MAX_BATCH_PROMPTS) {
        showError(`Maximum ${MAX_BATCH_PROMPTS} prompts allowed! You have ${prompts.length} prompts. Please remove ${prompts.length - MAX_BATCH_PROMPTS} prompts.`);
        return;
      }
      
      const threadCount = 4; // Fixed 4 parallel requests
      const aspectRatio = document.getElementById('aspectRatio').value;
      const imageCount = parseInt(document.getElementById('imageCount').value);
      const btn = document.getElementById('generateBtn');
      
      hideError();
      batchRunning = true;
      batchCancelled = false;
      btn.textContent = 'Cancel Batch';
      btn.onclick = cancelBatch;
      
      // Start generation timer
      startGenerationTimer();
      
      let completed = 0;
      let failed = 0;
      const total = prompts.length;
      const allImages = [];
      
      // Process reference images ONCE before batch (for cookie mode)
      let captionSuffix = '';
      let captionText = '';
      
      if (state.authMode === 'cookie') {
        let subjectCaption = '';
        let sceneCaption = '';
        let styleCaption = '';
        
        for (const type of ['subject', 'scene', 'style']) {
          if (state.references[type] && state.references[type].base64) {
            showStatus(`Analyzing ${type} image for batch...`);
            
            try {
              const uploadResult = await uploadReference(type, state.references[type].base64);
              console.log(`${type} upload result:`, uploadResult);
              
              if (uploadResult.caption) {
                const shortCaption = uploadResult.caption.substring(0, 300);
                
                if (type === 'subject') {
                  subjectCaption = shortCaption;
                  state.references.subject.caption = shortCaption;
                } else if (type === 'scene') {
                  sceneCaption = shortCaption;
                  state.references.scene.caption = shortCaption;
                } else if (type === 'style') {
                  styleCaption = shortCaption;
                  state.references.style.caption = shortCaption;
                }
              }
            } catch (err) {
              console.error(`Error processing ${type}:`, err);
            }
          }
        }
        
        // Build caption suffix to append to each prompt
        if (subjectCaption || sceneCaption || styleCaption) {
          let combinedParts = [];
          let captionParts = [];
          
          if (subjectCaption) {
            combinedParts.push(`Subject: ${subjectCaption}`);
            captionParts.push('Subject: ' + subjectCaption.substring(0, 50) + '...');
          }
          if (sceneCaption) {
            combinedParts.push(`Scene: ${sceneCaption}`);
            captionParts.push('Scene: ' + sceneCaption.substring(0, 50) + '...');
          }
          if (styleCaption) {
            combinedParts.push(`Style: ${styleCaption}`);
            captionParts.push('Style: ' + styleCaption.substring(0, 50) + '...');
          }
          
          captionSuffix = '. ' + combinedParts.join('. ');
          captionText = captionParts.join(' | ');
          console.log('Batch caption suffix ready:', captionSuffix.substring(0, 100));
        }
      }
      
      // Build queue with combined prompts
      const queue = prompts.map(p => ({
        originalPrompt: p,
        finalPrompt: p + captionSuffix
      }));
      
      showStatus(`Starting batch: 0/${total} completed (4 parallel)`);
      
      // Worker function - processes prompts from queue
      async function worker(workerId) {
        while (queue.length > 0 && !batchCancelled) {
          const item = queue.shift();
          if (!item) break;
          
          const { originalPrompt, finalPrompt } = item;
          
          try {
            showStatus(`Processing: ${completed}/${total} done, ${queue.length} pending...`);
            
            const response = await fetch('/api/generate', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                usePool: true,
                mode: state.authMode === 'cookie' ? 'reference' : 'text2img',
                prompt: finalPrompt,
                aspectRatio: aspectRatio,
                numImages: imageCount,
                workflowId: state.workflowId,
                sessionId: state.sessionId,
                seed: Math.floor(Math.random() * 2147483647)
              })
            });
            
            const result = await response.json();
            
            // Update remaining limit from response
            if (result.ipLimit) {
              updateRemainingLimit(result.ipLimit.remaining);
            }
            
            if (result.error) {
              console.error(`Failed prompt: ${originalPrompt}`, result.error);
              failed++;
              addFailedPrompt(originalPrompt);
            } else {
              // Extract and display image
              // Caption is now included in server response (uses same credential's cookies)
              let imageFound = false;
              if (result.imagePanels) {
                for (const panel of result.imagePanels) {
                  if (panel.generatedImages) {
                    for (const img of panel.generatedImages) {
                      if (img.encodedImage) {
                        allImages.push(img.encodedImage);
                        // Caption comes from server response
                        const imageCaption = img.caption || captionText || '';
                        displayResults([img.encodedImage], originalPrompt, imageCaption);
                        imageFound = true;
                      }
                    }
                  }
                }
              }
              if (result.generatedImages) {
                for (const img of result.generatedImages) {
                  if (img.encodedImage) {
                    allImages.push(img.encodedImage);
                    // Caption comes from server response
                    const imageCaption = img.caption || captionText || '';
                    displayResults([img.encodedImage], originalPrompt, imageCaption);
                    imageFound = true;
                  }
                }
              }
              if (imageFound) {
                completed++;
              } else {
                failed++;
                addFailedPrompt(originalPrompt);
              }
            }
            
            showStatus(`Processing: ${completed}/${total} done, ${failed} failed, ${queue.length} pending...`);
            
          } catch (err) {
            console.error(`Worker ${workerId} error:`, err);
            failed++;
            addFailedPrompt(originalPrompt);
          }
        }
      }
      
      try {
        // Start parallel workers
        const workers = [];
        for (let i = 0; i < threadCount; i++) {
          workers.push(worker(i + 1));
        }
        
        // Wait for all workers to complete
        await Promise.all(workers);
        
        hideStatus();
        stopGenerationTimer();
        if (batchCancelled) {
          showStatus(`Batch cancelled! ${completed}/${total} completed, ${failed} failed`);
        } else {
          showStatus(`Batch complete! ${completed}/${total} successful, ${failed} failed`);
        }
        setTimeout(hideStatus, 3000);
        
        // Track generation stats for batch
        if (allImages.length > 0) {
          trackGeneration(allImages.length);
        }
        
        if (document.getElementById('autoDownload').checked && allImages.length > 0) {
          downloadAllImages(allImages);
        }
        
      } catch (error) {
        hideStatus();
        stopGenerationTimer();
        console.error('Batch error:', error);
        showError('Batch error. Please try again.');
      } finally {
        batchRunning = false;
        btn.textContent = 'Start Batch Generation';
        btn.onclick = generateImages;
      }
    }
    
    function cancelBatch() {
      batchCancelled = true;
      showStatus('Cancelling batch... waiting for active requests to finish');
    }

    function displayResults(images, prompt, caption) {
      if (images.length === 0) {
        showError('No images were generated. Check console for details.');
        return;
      }
      
      // Add new images to history
      const timestamp = Date.now();
      images.forEach((base64, index) => {
        const imageId = `img_${timestamp}_${index}`;
        imageHistory.unshift({
          id: imageId,
          base64: base64,
          prompt: prompt,
          caption: caption,
          timestamp: timestamp
        });
      });
      
      // Reset to page 1 when new images arrive
      currentPage = 1;
      renderCurrentPage();
    }
    
    function renderCurrentPage() {
      const section = document.getElementById('resultsSection');
      const grid = document.getElementById('resultsGrid');
      
      if (imageHistory.length === 0) {
        section.style.display = 'none';
        return;
      }
      
      section.style.display = 'block';
      grid.innerHTML = '';
      
      // Update total count
      document.getElementById('totalImagesCount').textContent = imageHistory.length;
      
      // Calculate pagination
      const totalPages = Math.ceil(imageHistory.length / IMAGES_PER_PAGE);
      const startIndex = (currentPage - 1) * IMAGES_PER_PAGE;
      const endIndex = Math.min(startIndex + IMAGES_PER_PAGE, imageHistory.length);
      const pageItems = imageHistory.slice(startIndex, endIndex);
      
      // Render images for current page
      pageItems.forEach(item => {
        const card = document.createElement('div');
        card.className = 'result-card';
        card.id = item.id;
        card.innerHTML = `
          <img src="data:image/png;base64,${item.base64}" class="result-image" alt="Generated image">
          <div class="result-info">
            <div class="result-prompt-label">Prompt:</div>
            <div class="result-prompt">${escapeHtml(item.prompt)}</div>
            ${item.caption ? `<div class="result-caption"><div class="result-caption-label">Captions:</div>${escapeHtml(item.caption)}</div>` : ''}
          </div>
          <div class="result-actions">
            <button class="btn btn-icon" onclick="copyPrompt('${item.id}')" title="Copy Prompt">
              üìã Copy
            </button>
            <button class="btn btn-icon" onclick="editAndRegenerate('${item.id}')" title="Edit & Regenerate">
              ‚úèÔ∏è Edit
            </button>
            <button class="btn btn-primary" onclick="downloadSingleImage('${item.id}')">
              Download
            </button>
          </div>
        `;
        grid.appendChild(card);
      });
      
      // Update pagination controls
      updatePaginationControls(totalPages);
    }
    
    function updatePaginationControls(totalPages) {
      const controls = document.getElementById('paginationControls');
      const pageNumbersDiv = document.getElementById('pageNumbers');
      
      if (totalPages <= 1) {
        controls.style.display = 'none';
        return;
      }
      
      controls.style.display = 'flex';
      
      // Previous button
      document.getElementById('prevPageBtn').style.display = currentPage > 1 ? 'block' : 'none';
      
      // Next and Last buttons
      document.getElementById('nextPageBtn').style.display = currentPage < totalPages ? 'block' : 'none';
      document.getElementById('lastPageBtn').style.display = currentPage < totalPages ? 'block' : 'none';
      
      // Page numbers
      pageNumbersDiv.innerHTML = '';
      
      let startPage = Math.max(1, currentPage - 4);
      let endPage = Math.min(totalPages, startPage + 9);
      
      if (endPage - startPage < 9) {
        startPage = Math.max(1, endPage - 9);
      }
      
      // First page button if not visible
      if (startPage > 1) {
        const firstBtn = document.createElement('button');
        firstBtn.className = 'page-btn';
        firstBtn.textContent = '1';
        firstBtn.onclick = () => goToPage(1);
        pageNumbersDiv.appendChild(firstBtn);
        
        if (startPage > 2) {
          const dots = document.createElement('span');
          dots.textContent = '...';
          dots.style.padding = '0 8px';
          dots.style.color = '#888';
          pageNumbersDiv.appendChild(dots);
        }
      }
      
      // Page number buttons
      for (let i = startPage; i <= endPage; i++) {
        const btn = document.createElement('button');
        btn.className = 'page-btn' + (i === currentPage ? ' active' : '');
        btn.textContent = i;
        btn.onclick = () => goToPage(i);
        pageNumbersDiv.appendChild(btn);
      }
      
      // Last page dots
      if (endPage < totalPages) {
        if (endPage < totalPages - 1) {
          const dots = document.createElement('span');
          dots.textContent = '...';
          dots.style.padding = '0 8px';
          dots.style.color = '#888';
          pageNumbersDiv.appendChild(dots);
        }
        
        const lastBtn = document.createElement('button');
        lastBtn.className = 'page-btn';
        lastBtn.textContent = totalPages;
        lastBtn.onclick = () => goToPage(totalPages);
        pageNumbersDiv.appendChild(lastBtn);
      }
    }
    
    function goToPage(page) {
      currentPage = page;
      renderCurrentPage();
      window.scrollTo({ top: document.getElementById('resultsSection').offsetTop - 20, behavior: 'smooth' });
    }
    
    function changePage(direction) {
      const totalPages = Math.ceil(imageHistory.length / IMAGES_PER_PAGE);
      
      if (direction === 'prev' && currentPage > 1) {
        currentPage--;
      } else if (direction === 'next' && currentPage < totalPages) {
        currentPage++;
      } else if (direction === 'last') {
        currentPage = totalPages;
      }
      
      renderCurrentPage();
      window.scrollTo({ top: document.getElementById('resultsSection').offsetTop - 20, behavior: 'smooth' });
    }
    
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    function copyPrompt(imageId) {
      const item = imageHistory.find(i => i.id === imageId);
      if (item) {
        let textToCopy = 'Prompt: ' + item.prompt;
        if (item.caption) {
          textToCopy += '\n\nCaptions: ' + item.caption;
        }
        navigator.clipboard.writeText(textToCopy).then(() => {
          showStatus('Copied to clipboard!');
          setTimeout(hideStatus, 1500);
        });
      }
    }
    
    function copyAllPrompts() {
      if (imageHistory.length === 0) {
        showError('No images in history to copy');
        return;
      }
      
      const allText = imageHistory.map((item, index) => {
        let text = `--- Image ${index + 1} ---\nPrompt: ${item.prompt}`;
        if (item.caption) {
          text += `\nCaptions: ${item.caption}`;
        }
        return text;
      }).join('\n\n');
      
      navigator.clipboard.writeText(allText).then(() => {
        showStatus('All prompts copied to clipboard!');
        setTimeout(hideStatus, 1500);
      });
    }
    
    function copyAllCaptions() {
      if (imageHistory.length === 0) {
        showError('No images in history');
        return;
      }
      
      // Collect only captions (not prompts)
      const captionsOnly = imageHistory
        .filter(item => item.caption && item.caption.trim() !== '')
        .map((item, index) => `--- Image ${index + 1} ---\n${item.caption}`)
        .join('\n\n');
      
      if (!captionsOnly) {
        showError('No captions found in history');
        return;
      }
      
      navigator.clipboard.writeText(captionsOnly).then(() => {
        showStatus('All captions copied to clipboard!');
        setTimeout(hideStatus, 1500);
      });
    }
    
    function editAndRegenerate(imageId) {
      const item = imageHistory.find(i => i.id === imageId);
      if (item) {
        // Show prompt in an editable modal/prompt
        const newPrompt = window.prompt('Edit prompt and regenerate:', item.prompt);
        if (newPrompt && newPrompt.trim() !== '') {
          // Set the prompt and generate
          document.getElementById('promptInput').value = newPrompt.trim();
          // Generate with new prompt
          generateImages();
        }
      }
    }
    
    // Helper function to create clean filename from prompt
    function createFilenameFromPrompt(prompt, maxLength = 100) {
      if (!prompt) return 'image';
      
      // Take first 100 characters
      let filename = prompt.substring(0, maxLength);
      
      // Remove all symbols except letters, numbers, spaces, and hyphens
      filename = filename.replace(/[^a-zA-Z0-9\s\-]/g, '');
      
      // Replace multiple spaces with single space
      filename = filename.replace(/\s+/g, ' ').trim();
      
      // Replace spaces with underscores
      filename = filename.replace(/\s/g, '_');
      
      // Remove multiple underscores
      filename = filename.replace(/_+/g, '_');
      
      // Trim underscores from start and end
      filename = filename.replace(/^_+|_+$/g, '');
      
      // If empty after cleaning, use default
      if (!filename) return 'image';
      
      return filename;
    }
    
    async function downloadZip() {
      if (imageHistory.length === 0) {
        showError('No images to download');
        return;
      }
      
      if (typeof JSZip === 'undefined') {
        showError('ZIP library not loaded. Please refresh the page and try again.');
        return;
      }
      
      showStatus('Creating ZIP file...');
      
      try {
        const zip = new JSZip();
        const folder = zip.folder('whisk_images');
        
        // Track used filenames to avoid duplicates
        const usedFilenames = {};
        
        // Add images to ZIP with prompt-based names
        imageHistory.forEach((item, index) => {
          let baseFilename = createFilenameFromPrompt(item.prompt, 100);
          let filename = baseFilename;
          
          // Handle duplicate filenames by adding number
          if (usedFilenames[filename]) {
            usedFilenames[filename]++;
            filename = `${baseFilename}_${usedFilenames[filename]}`;
          } else {
            usedFilenames[filename] = 1;
          }
          
          folder.file(`${filename}.png`, item.base64, {base64: true});
        });
        
        // Add prompts text file
        const promptsText = imageHistory.map((item, index) => {
          const filename = createFilenameFromPrompt(item.prompt, 100);
          let text = `--- Image ${index + 1} (${filename}.png) ---\nPrompt: ${item.prompt}`;
          if (item.caption) {
            text += `\nCaptions: ${item.caption}`;
          }
          return text;
        }).join('\n\n');
        folder.file('prompts.txt', promptsText);
        
        // Generate and download ZIP
        const content = await zip.generateAsync({type: 'blob'});
        const link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        link.download = `whisk_images_${Date.now()}.zip`;
        link.click();
        
        hideStatus();
        showStatus('ZIP downloaded!');
        setTimeout(hideStatus, 1500);
      } catch (error) {
        hideStatus();
        showError('Failed to create ZIP. Please try again.');
      }
    }
    
    function downloadSingleImage(imageId) {
      const itemIndex = imageHistory.findIndex(i => i.id === imageId);
      if (itemIndex !== -1) {
        const item = imageHistory[itemIndex];
        
        // Create filename from prompt (first 100 chars, remove symbols)
        const filename = createFilenameFromPrompt(item.prompt, 100);
        
        const link = document.createElement('a');
        link.href = 'data:image/png;base64,' + item.base64;
        link.download = `${filename}.png`;
        link.click();
        
        // Remove from history after download
        imageHistory.splice(itemIndex, 1);
        
        // Update the display
        document.getElementById('totalImagesCount').textContent = imageHistory.length;
        
        // Remove card from DOM
        const card = document.getElementById(imageId);
        if (card) {
          card.style.transition = 'opacity 0.3s, transform 0.3s';
          card.style.opacity = '0';
          card.style.transform = 'scale(0.8)';
          setTimeout(() => {
            card.remove();
            // Re-render if page is empty
            const grid = document.getElementById('resultsGrid');
            if (grid.children.length === 0 && imageHistory.length > 0) {
              renderCurrentPage();
            } else if (imageHistory.length === 0) {
              document.getElementById('resultsSection').style.display = 'none';
            }
          }, 300);
        }
      }
    }
    
    function clearHistory() {
      const grid = document.getElementById('resultsGrid');
      grid.innerHTML = '';
      imageHistory.length = 0; // Clear history array
      currentPage = 1; // Reset pagination
      document.getElementById('resultsSection').style.display = 'none';
      document.getElementById('paginationControls').style.display = 'none';
      document.getElementById('totalImagesCount').textContent = '0';
    }

    function downloadImage(base64, filename) {
      const link = document.createElement('a');
      link.href = 'data:image/png;base64,' + base64;
      link.download = filename.endsWith('.png') ? filename : `${filename}.png`;
      link.click();
    }

    function downloadAllImages(images, prompts = []) {
      images.forEach((base64, index) => {
        setTimeout(() => {
          const prompt = prompts[index] || '';
          const filename = createFilenameFromPrompt(prompt, 100) || `image_${index + 1}`;
          downloadImage(base64, `${filename}.png`);
        }, index * 500);
      });
    }

    // Failed prompts functions
    function addFailedPrompt(prompt) {
      if (!failedPrompts.includes(prompt)) {
        failedPrompts.push(prompt);
        updateFailedPromptsDisplay();
      }
    }
    
    function updateFailedPromptsDisplay() {
      const section = document.getElementById('failedPromptsSection');
      const textarea = document.getElementById('failedPromptsList');
      const countSpan = document.getElementById('failedCount');
      
      if (failedPrompts.length === 0) {
        section.style.display = 'none';
        return;
      }
      
      section.style.display = 'block';
      textarea.value = failedPrompts.join('\n');
      countSpan.textContent = failedPrompts.length;
    }
    
    function copyFailedPrompts() {
      const text = failedPrompts.join('\n');
      navigator.clipboard.writeText(text).then(() => {
        showStatus('Failed prompts copied!');
        setTimeout(hideStatus, 1500);
      });
    }
    
    function retryFailedPrompts() {
      if (failedPrompts.length === 0) return;
      
      // Copy failed prompts to batch input
      document.getElementById('batchPromptInput').value = failedPrompts.join('\n');
      
      // Switch to batch mode
      switchPromptMode('batch');
      
      // Clear failed prompts
      clearFailedPrompts();
      
      // Update prompt count
      updatePromptCount();
      
      showStatus('Failed prompts loaded in Batch Mode - click Generate to retry!');
      setTimeout(hideStatus, 3000);
    }
    
    function clearFailedPrompts() {
      failedPrompts.length = 0;
      updateFailedPromptsDisplay();
    }

    // Check for JSZip availability at startup
    window.addEventListener('load', function() {
      if (typeof JSZip === 'undefined') {
        const zipBtn = document.querySelector('button[onclick="downloadZip()"]');
        if (zipBtn) {
          zipBtn.disabled = true;
          zipBtn.title = 'ZIP library not available - refresh page';
          zipBtn.style.opacity = '0.5';
        }
      }
    });

    // ============================================
    // ANTI-TAMPER GUARD - Script Protection System
    // Copy/Paste allowed, DevTools blocked
    // ============================================
    (function() {
      'use strict';
      
      // Context menu state
      let contextMenuVisible = false;
      let contextMenuX = 0;
      let contextMenuY = 0;
      let hasSelection = false;
      let hasInputTarget = false;
      let targetElement = null;
      
      // Create custom context menu element
      const contextMenu = document.createElement('div');
      contextMenu.id = 'customContextMenu';
      contextMenu.setAttribute('data-context-menu', 'true');
      contextMenu.style.cssText = `
        position: fixed;
        display: none;
        background-color: #1f2937;
        border: 1px solid #374151;
        border-radius: 8px;
        padding: 4px 0;
        z-index: 999999;
        min-width: 120px;
        box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      `;
      
      // Create Copy button
      const copyBtn = document.createElement('button');
      copyBtn.textContent = 'Copy';
      copyBtn.style.cssText = `
        display: block;
        width: 100%;
        padding: 8px 16px;
        text-align: left;
        background: transparent;
        border: none;
        color: #fff;
        cursor: pointer;
        font-size: 14px;
        transition: background 0.2s;
      `;
      copyBtn.onmouseover = () => copyBtn.style.background = 'rgba(255,255,255,0.1)';
      copyBtn.onmouseout = () => copyBtn.style.background = 'transparent';
      
      // Create Paste button
      const pasteBtn = document.createElement('button');
      pasteBtn.textContent = 'Paste';
      pasteBtn.style.cssText = `
        display: block;
        width: 100%;
        padding: 8px 16px;
        text-align: left;
        background: transparent;
        border: none;
        color: #fff;
        cursor: pointer;
        font-size: 14px;
        transition: background 0.2s;
      `;
      pasteBtn.onmouseover = () => pasteBtn.style.background = 'rgba(255,255,255,0.1)';
      pasteBtn.onmouseout = () => pasteBtn.style.background = 'transparent';
      
      contextMenu.appendChild(copyBtn);
      contextMenu.appendChild(pasteBtn);
      document.body.appendChild(contextMenu);
      
      // Allowed keyboard shortcuts
      const ALLOWED_KEYS = ['c', 'v', 'z', 'a', 'x'];
      
      // Block keyboard shortcuts (Ctrl+U, Ctrl+Shift+I, F12, etc)
      document.addEventListener('keydown', function(e) {
        if (e.ctrlKey || e.metaKey) {
          const key = e.key.toLowerCase();
          
          // Block all Ctrl+Shift combinations (DevTools shortcuts)
          if (e.shiftKey) {
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
          
          // Block Ctrl keys except copy/paste/undo/select-all/cut
          if (!ALLOWED_KEYS.includes(key)) {
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
        }
        
        // Block F12 (DevTools)
        if (e.key === 'F12') {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
        
        // Block Ctrl+Shift+J (Console)
        if (e.key === 'j' && e.ctrlKey && e.shiftKey) {
          e.preventDefault();
          return false;
        }
      }, true);
      
      // Custom right-click menu handler
      document.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const target = e.target;
        
        // Find input target
        let inputTarget = null;
        if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
          inputTarget = target;
        } else if (target.isContentEditable) {
          inputTarget = target;
        } else {
          inputTarget = target.closest("input, textarea, [contenteditable='true']");
        }
        
        targetElement = inputTarget;
        
        const selection = window.getSelection()?.toString() || '';
        hasSelection = selection.length > 0;
        hasInputTarget = inputTarget !== null;
        
        // Update button states
        copyBtn.disabled = !hasSelection;
        copyBtn.style.color = hasSelection ? '#fff' : '#6b7280';
        copyBtn.style.cursor = hasSelection ? 'pointer' : 'not-allowed';
        
        pasteBtn.disabled = !hasInputTarget;
        pasteBtn.style.color = hasInputTarget ? '#fff' : '#6b7280';
        pasteBtn.style.cursor = hasInputTarget ? 'pointer' : 'not-allowed';
        
        // Position menu
        contextMenuX = Math.min(e.clientX, window.innerWidth - 140);
        contextMenuY = Math.min(e.clientY, window.innerHeight - 100);
        
        contextMenu.style.left = contextMenuX + 'px';
        contextMenu.style.top = contextMenuY + 'px';
        contextMenu.style.display = 'block';
        contextMenuVisible = true;
        
        return false;
      }, true);
      
      // Copy handler
      copyBtn.addEventListener('click', async function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        try {
          const selection = window.getSelection()?.toString();
          if (selection) {
            await navigator.clipboard.writeText(selection);
          }
        } catch (err) {
          document.execCommand('copy');
        }
        
        hideContextMenu();
      });
      
      // Paste handler
      pasteBtn.addEventListener('click', async function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        try {
          const text = await navigator.clipboard.readText();
          
          if (targetElement && (targetElement.tagName === 'INPUT' || targetElement.tagName === 'TEXTAREA')) {
            targetElement.focus();
            
            const start = targetElement.selectionStart || 0;
            const end = targetElement.selectionEnd || 0;
            const currentValue = targetElement.value;
            
            const newValue = currentValue.slice(0, start) + text + currentValue.slice(end);
            targetElement.value = newValue;
            targetElement.selectionStart = targetElement.selectionEnd = start + text.length;
            
            targetElement.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
            targetElement.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));
            
          } else if (targetElement?.isContentEditable) {
            targetElement.focus();
            document.execCommand('insertText', false, text);
          }
        } catch (err) {
          if (targetElement) {
            targetElement.focus();
            document.execCommand('paste');
          }
        }
        
        hideContextMenu();
      });
      
      // Hide context menu function
      function hideContextMenu() {
        contextMenu.style.display = 'none';
        contextMenuVisible = false;
      }
      
      // Close menu on click outside
      document.addEventListener('click', function(e) {
        if (!e.target.closest('[data-context-menu]')) {
          hideContextMenu();
        }
      }, true);
      
      // Close menu on scroll
      document.addEventListener('scroll', hideContextMenu, true);
      
      // Close menu on Escape key
      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
          hideContextMenu();
        }
      });
      
      // Prevent context menu on our custom menu
      contextMenu.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        e.stopPropagation();
      });
      
      // Disable right-click on images (extra protection)
      document.addEventListener('dragstart', function(e) {
        if (e.target.tagName === 'IMG') {
          e.preventDefault();
        }
      });
      
      console.log('Anti-Tamper Guard: Protection enabled');
    })();
  </script>
  
  <!-- Social Popup Styles -->
  <style>
    .social-popup-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }
    
    .social-popup-overlay.visible {
      opacity: 1;
      visibility: visible;
    }
    
    .social-popup {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      border-radius: 20px;
      padding: 30px 40px;
      max-width: 400px;
      width: 90%;
      text-align: center;
      border: 2px solid rgba(102, 126, 234, 0.5);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      transform: scale(0.8);
      transition: transform 0.3s ease;
    }
    
    .social-popup-overlay.visible .social-popup {
      transform: scale(1);
    }
    
    .social-popup-title {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 8px;
      background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .social-popup-subtitle {
      color: #a0a0a0;
      font-size: 1rem;
      margin-bottom: 25px;
    }
    
    .social-links {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 25px;
    }
    
    .social-link {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 20px;
      border-radius: 12px;
      text-decoration: none;
      color: #fff;
      font-weight: 600;
      transition: all 0.3s ease;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .social-link:hover {
      transform: translateX(5px);
      border-color: rgba(255, 255, 255, 0.3);
    }
    
    .social-link.facebook {
      background: linear-gradient(135deg, #1877f2, #0d5bbd);
    }
    
    .social-link.facebook:hover {
      background: linear-gradient(135deg, #0d5bbd, #094a9e);
    }
    
    .social-link.whatsapp {
      background: linear-gradient(135deg, #25d366, #128c48);
    }
    
    .social-link.whatsapp:hover {
      background: linear-gradient(135deg, #128c48, #0e6b38);
    }
    
    .social-link svg {
      width: 24px;
      height: 24px;
      flex-shrink: 0;
    }
    
    .social-link-text {
      flex: 1;
      text-align: left;
    }
    
    .social-popup-close {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      padding: 12px 30px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9rem;
      transition: all 0.3s ease;
      margin-bottom: 20px;
    }
    
    .social-popup-close:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    
    .social-popup-footer {
      color: #666;
      font-size: 0.85rem;
      padding-top: 15px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .social-popup-footer a {
      color: #667eea;
      text-decoration: none;
      font-weight: 600;
      transition: color 0.3s;
    }
    
    .social-popup-footer a:hover {
      color: #48dbfb;
    }
    
    /* Corner Button */
    .social-corner-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 56px;
      height: 56px;
      background: linear-gradient(135deg, #25d366 0%, #1877f2 100%);
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 2px;
      box-shadow: 0 4px 15px rgba(37, 211, 102, 0.4);
      z-index: 9999;
      transition: all 0.3s ease;
    }
    
    .social-corner-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 20px rgba(24, 119, 242, 0.6);
    }
    
    .social-corner-btn svg {
      width: 20px;
      height: 20px;
      fill: white;
    }
    
    .social-corner-btn .wa-icon {
      margin-right: -2px;
    }
    
    .social-corner-btn .fb-icon {
      margin-left: -2px;
    }
  </style>
  
  <!-- Social Popup HTML -->
  <div class="social-popup-overlay" id="socialPopup">
    <div class="social-popup">
      <div class="social-popup-title">Join Our Community!</div>
      <div class="social-popup-subtitle">Click any link to join and continue</div>
           
        <a href="https://www.whatsapp.com/channel/0029VbBoEt19cDDiTAk69X2L" target="_blank" class="social-link whatsapp" onclick="markSocialJoined()">
          <svg viewBox="0 0 24 24" fill="currentColor" />
          <span class="social-link-text">WhatsApp Group</span>
        </a>
      </div>
   
  <!-- Corner Button to Reopen Popup -->
  <button class="social-corner-btn" id="socialCornerBtn" onclick="openSocialPopup()" title="Join Our Community">
    <svg class="wa-icon" viewBox="0 0 24 24" fill="currentColor" />
    <svg class="fb-icon" viewBox="0 0 24 24" fill="currentColor" />
  </button>
  
  <!-- Social Popup Script -->
  <script>
    // Check if popup should be shown (server-side IP tracking)
    async function checkSocialPopup() {
      try {
        const response = await fetch('/api/social/check');
        const data = await response.json();
        
        if (!data.joined) {
          setTimeout(() => {
            openSocialPopup();
          }, 1000);
        }
      } catch (e) {
        console.error('Social check error:', e);
      }
    }
    
    function openSocialPopup() {
      document.getElementById('socialPopup').classList.add('visible');
    }
    
    function closeSocialPopup() {
      document.getElementById('socialPopup').classList.remove('visible');
    }
    
    // Mark as joined when user clicks any social link
    async function markSocialJoined() {
      try {
        await fetch('/api/social/join', { method: 'POST' });
        closeSocialPopup();
      } catch (e) {
        console.error('Social join error:', e);
        closeSocialPopup();
      }
    }
   
  <footer style="text-align: center; padding: 30px 20px; margin-top: 40px; border-top: 1px solid rgba(255,255,255,0.1); color: rgba(255,255,255,0.6); font-size: 14px;">
    Developed with <span style="color: #ff6b6b;">‚ù§Ô∏è</span> by <span style="color: #4ecdc4; font-weight: 600;">Zafar Abbas</span>
  </footer>
</body>
</html>
